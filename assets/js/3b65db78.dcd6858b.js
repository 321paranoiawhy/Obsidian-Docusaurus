"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2554],{3905:(e,n,r)=>{r.d(n,{Zo:()=>u,kt:()=>m});var t=r(7294);function o(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function a(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?a(Object(r),!0).forEach((function(n){o(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=t.createContext({}),d=function(e){var n=t.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},u=function(e){var n=d(e.components);return t.createElement(c.Provider,{value:n},e.children)},s="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),s=d(r),f=o,m=s["".concat(c,".").concat(f)]||s[f]||p[f]||a;return r?t.createElement(m,i(i({ref:n},u),{},{components:r})):t.createElement(m,i({ref:n},u))}));function m(e,n){var r=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=f;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[s]="string"==typeof e?e:o,i[1]=l;for(var d=2;d<a;d++)i[d]=r[d];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}f.displayName="MDXCreateElement"},6829:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var t=r(7462),o=(r(7294),r(3905));const a={title:"130. Surrounded Regions","date created":"Thursday, December 1st 2022, 10:33:06 am","date modified":"Thursday, December 1st 2022, 10:52:31 am"},i="130. Surrounded Regions",l={unversionedId:"Algo/Coding Practice/Graph/Surrounded Regions",id:"Algo/Coding Practice/Graph/Surrounded Regions",title:"130. Surrounded Regions",description:"DFS Solution",source:"@site/docs/Algo/Coding Practice/Graph/130. Surrounded Regions.md",sourceDirName:"Algo/Coding Practice/Graph",slug:"/Algo/Coding Practice/Graph/Surrounded Regions",permalink:"/Obsidian-Docusaurus/docs/Algo/Coding Practice/Graph/Surrounded Regions",draft:!1,editUrl:"https://github.com/321paranoiawhy/321paranoiawhy.github.io/blob/main/docs/Algo/Coding Practice/Graph/130. Surrounded Regions.md",tags:[],version:"current",sidebarPosition:130,frontMatter:{title:"130. Surrounded Regions","date created":"Thursday, December 1st 2022, 10:33:06 am","date modified":"Thursday, December 1st 2022, 10:52:31 am"},sidebar:"tutorialSidebar",previous:{title:"Longest Common Sub-string",permalink:"/Obsidian-Docusaurus/docs/Algo/Coding Practice/DP/Longest common substring"},next:{title:"178 Graph Valid",permalink:"/Obsidian-Docusaurus/docs/Algo/Coding Practice/Graph/178 Graph Valid"}},c={},d=[{value:"DFS Solution",id:"dfs-solution",level:2},{value:"BFS Solution",id:"bfs-solution",level:2}],u={toc:d},s="wrapper";function p(e){let{components:n,...r}=e;return(0,o.kt)(s,(0,t.Z)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"130-surrounded-regions"},"130. Surrounded Regions"),(0,o.kt)("h2",{id:"dfs-solution"},"DFS Solution"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The trick to get to the solution is to think reverse.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The only regions that will be changed to X are Os that are at the border and other Os that are 4-directionally connected to them."),(0,o.kt)("li",{parentName:"ul"},"Our solution will have two parts",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"find all the Os that are at the border and all the other Os connected to them",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"we will mark/flag them with ","*"),(0,o.kt)("li",{parentName:"ul"},"we can use DFS to do this"))),(0,o.kt)("li",{parentName:"ul"},"one the second part all the Os that haven't been marked will have to be changed to X",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"also change ","*"," back to O")))))))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        R,C = len(board), len(board[0])\n        \n        def DFS(r,c):\n            if r < 0 or c < 0:\n                return\n            if r >= R or c >= C:\n                return\n            if board[r][c] != 'O':\n                return\n            \n            board[r][c] = '*' #flag Os and all related\n            DFS(r+1,c)\n            DFS(r-1,c)\n            DFS(r,c+1)\n            DFS(r,c-1)\n        \n        \n        for r in range(R):\n            for c in range(C):\n                #Run DFS for Os at a border\n                if board[r][c] == 'O' and (r in [0,R-1] or c in [0, C-1]):\n                    DFS(r,c)\n\n        #Canage O -> X and, * -> O\n        for r in range(R):\n            for c in range(C):\n                curr = board[r][c]\n                if curr == '*':\n                    board[r][c] = 'O'\n                elif curr == 'O':\n                    board[r][c] = 'X'\n                    \n        \n")),(0,o.kt)("h2",{id:"bfs-solution"},"BFS Solution"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n  def solve(self, board: List[List[str]]) -> None:\n    if not board:\n      return\n\n    m = len(board)\n    n = len(board[0])\n    dirs = [0, 1, 0, -1, 0]\n    q = deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    # Mark grids that stretch from four sides with '*'\n    while q:\n      i, j = q.popleft()\n      for k in range(4):\n        x = i + dirs[k]\n        y = j + dirs[k + 1]\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        row[i] = 'O' if c == '*' else 'X'\n")))}p.isMDXComponent=!0}}]);