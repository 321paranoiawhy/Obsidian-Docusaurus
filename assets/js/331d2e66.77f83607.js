"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5850],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,h=d["".concat(o,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[d]="string"==typeof e?e:r,l[1]=s;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5773:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={title:"400. Pre-rendering","date created":"Thursday, November 3rd 2022, 1:19:51 pm","date modified":"Thursday, December 8th 2022, 4:05:50 pm"},l="400. Pre-rendering",s={unversionedId:"Frameworks/Nextjs/Static site generation",id:"Frameworks/Nextjs/Static site generation",title:"400. Pre-rendering",description:"What and Why Pre-rendering",source:"@site/docs/Frameworks/Nextjs/400. Static site generation.md",sourceDirName:"Frameworks/Nextjs",slug:"/Frameworks/Nextjs/Static site generation",permalink:"/Obsidian-Docusaurus/docs/Frameworks/Nextjs/Static site generation",draft:!1,editUrl:"https://github.com/zekaryas1/notes/blob/main/docs/Frameworks/Nextjs/400. Static site generation.md",tags:[],version:"current",sidebarPosition:400,frontMatter:{title:"400. Pre-rendering","date created":"Thursday, November 3rd 2022, 1:19:51 pm","date modified":"Thursday, December 8th 2022, 4:05:50 pm"},sidebar:"tutorialSidebar",previous:{title:"300. Routing",permalink:"/Obsidian-Docusaurus/docs/Frameworks/Nextjs/Routing"},next:{title:"500. Server Side Rendering",permalink:"/Obsidian-Docusaurus/docs/Frameworks/Nextjs/Server side rendering"}},o={},u=[{value:"What and Why Pre-rendering",id:"what-and-why-pre-rendering",level:2},{value:"What is Pre-rendering",id:"what-is-pre-rendering",level:3},{value:"Why Pre-rendering",id:"why-pre-rendering",level:3},{value:"Types of Rendering",id:"types-of-rendering",level:2},{value:"Static Site Generation",id:"static-site-generation",level:3},{value:"SSG and Link Component",id:"ssg-and-link-component",level:4},{value:"SSG + getStaticPaths",id:"ssg--getstaticpaths",level:4},{value:"Fallback Key",id:"fallback-key",level:4},{value:"What if Key is Not Found",id:"what-if-key-is-not-found",level:3},{value:"Pros and Cons of SSG",id:"pros-and-cons-of-ssg",level:3},{value:"ISR {incremental Static Site regeneration}",id:"isr-incremental-static-site-regeneration",level:3},{value:"Programmatic Revalidation",id:"programmatic-revalidation",level:4}],p={toc:u},d="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"400-pre-rendering"},"400. Pre-rendering"),(0,r.kt)("h2",{id:"what-and-why-pre-rendering"},"What and Why Pre-rendering"),(0,r.kt)("h3",{id:"what-is-pre-rendering"},"What is Pre-rendering"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"By default, Next.js pre-renders every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript."),(0,r.kt)("li",{parentName:"ul"},"Pre-rendering can result in better performance and SEO.")),(0,r.kt)("h3",{id:"why-pre-rendering"},"Why Pre-rendering"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"better performance"),(0,r.kt)("li",{parentName:"ul"},"SEO benefit")),(0,r.kt)("h2",{id:"types-of-rendering"},"Types of Rendering"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Next.js has two forms of pre-rendering: Static Generation and Server-side Rendering. The difference is in when it generates the HTML for a page.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Static site generation(SSG) = ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticProps")," = data fetched at build time",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Incremental static site regeneration(ISR)"),(0,r.kt)("li",{parentName:"ul"},"Dynamic static site generation = ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticPaths")))),(0,r.kt)("li",{parentName:"ul"},"Server side rendering = ",(0,r.kt)("inlineCode",{parentName:"li"},"getServerSideProps")," = data fetched on each request"))),(0,r.kt)("li",{parentName:"ul"},"Client side data fetching can be added on both type of rendering")),(0,r.kt)("h3",{id:"static-site-generation"},"Static Site Generation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://nextjs.org/docs/basic-features/data-fetching/get-static-props"},"Next.js get-static-props")),(0,r.kt)("li",{parentName:"ul"},"The HTML with all the data that makes up the content of the web page are generated in advance when you build your application."),(0,r.kt)("li",{parentName:"ul"},"==The default pre-rendering method=="),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("em",{parentName:"li"},"recommended")," method to pre-render pages whenever possible."),(0,r.kt)("li",{parentName:"ul"},"Can be built once and served cache version from CDN. resulting faster delivery time."),(0,r.kt)("li",{parentName:"ul"},"variation of SSG",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"without data"),(0,r.kt)("li",{parentName:"ul"},"with data"),(0,r.kt)("li",{parentName:"ul"},"incremental static regeneration"),(0,r.kt)("li",{parentName:"ul"},"dynamic parameters when fetching data")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"//static generation without data\nfunction Home(){\n    return <h1>about us page</h1>\n}\nexport default Home;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'//static generation with data\nfunction Home({ users }) {\n  return (\n    <div>\n      {users.map((user) => {\n        return (\n          <>\n            <p>\n              {user.firstName} {user.lastName}{" "}\n            </p>\n          </>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default Home;\n\nexport async function getStaticProps() {\n  const response = await fetch("https://dummyjson.com/users");\n  const data = await response.json();\n\n  return {\n    props: {\n      users: data.users,\n    },\n  };\n}\n\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"getStaticProps",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"can write any back-end logic here,",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"ex: accessing file system, DB"))),(0,r.kt)("li",{parentName:"ul"},"code her wont't be shipped to browser, only back-end",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"on runs on the back-end"))),(0,r.kt)("li",{parentName:"ul"},"only can be used in pages,",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"not in components, client-side or anywhere else."))),(0,r.kt)("li",{parentName:"ul"},"must return an object with props key"),(0,r.kt)("li",{parentName:"ul"},"will run only once during build time: production",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"except on development time. it will run on every request")))))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"getStaticProps does not have access to the incoming request (such as query parameters or HTTP headers) as it generates static HTML.")),(0,r.kt)("h4",{id:"ssg-and-link-component"},"SSG and Link Component"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Any ",(0,r.kt)("inlineCode",{parentName:"li"},"Link")," component in the view-port(initially or on scroll) will be prefetched by default including the corresponding data for pages using static site generation.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/Obsidian-Docusaurus/docs/Frameworks/Nextjs/More%20on%20nextjs#Prefetching"},"Prefetching")))),(0,r.kt)("li",{parentName:"ul"},"When a page with ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticProps")," is pre-rendered at build time, nextjs renders.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"HTML page,"),(0,r.kt)("li",{parentName:"ul"},"JSON {holding the result of ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticProps"),"}"),(0,r.kt)("li",{parentName:"ul"},"and the required JS chunk."))),(0,r.kt)("li",{parentName:"ul"},"The JSON file will be used in client-side routing through next/link or next/router."),(0,r.kt)("li",{parentName:"ul"},"When you navigate to a page that's pre-rendered using ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticProps"),", Next.js fetches",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The JSON file which is pre-computed at build time",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"This JSON is used as a prop to create the page component client-side.")))))),(0,r.kt)("h4",{id:"ssg--getstaticpaths"},"SSG + getStaticPaths"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If a page has Dynamic Routes and uses getStaticProps, it needs to define a list of paths to be statically generated."),(0,r.kt)("li",{parentName:"ul"},"When you export a function called getStaticPaths (Static Site Generation) from a page that uses dynamic routes, Next.js will statically pre-render all the paths specified by getStaticPaths.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function UserDetail({user}) {  \n    //...component ui\n}  \n  \nexport default UserDetail;  \n\n// generate pre-render for all ids\nexport async function getStaticPaths() {  \n    const response = await fetch(`https://dummyjson.com/users`);  \n    const data = await response.json();  \n  \n    const paths = data.users.map((user) => ({  \n        params: { userid: `${user.id}` },  \n    }))  \n  \n    return {  \n        paths: paths,  \n        // paths: [{params: {userid: '1'}}, {params: {userid: '2'}}],  \n        fallback: false, // can also be true or 'blocking'  \n    }  \n}\n\n// generate pre-render for certain ids\nexport async function getStaticPaths() {\n\n    return {\n        paths: [\n            {params: {userid: '1'}},\n            {params: {userid: '2'}},\n            {params: {userid: '3'}},\n        ],\n        fallback: false, // can also be true or 'blocking'\n    }\n}\n  \nexport async function getStaticProps(context) {  \n    const {params} = context;  \n    const response = await fetch(`https://dummyjson.com/users/${params.userid}`);  \n    const data = await response.json();  \n  \n    return {  \n        props: {  \n            user: data,  \n        },  \n    };  \n}\n")),(0,r.kt)("h4",{id:"fallback-key"},"Fallback Key"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"fallback key is a required value with getstaticPath"),(0,r.kt)("li",{parentName:"ul"},"can have the following possible values",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"false",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"any paths not returned by getStaticPaths, will result in 404 page."),(0,r.kt)("li",{parentName:"ul"},"when should you use this?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if you have a small number of pages pre-render with getStaticPaths"),(0,r.kt)("li",{parentName:"ul"},"when new pages are not added often"),(0,r.kt)("li",{parentName:"ul"},"ex: a blog site with a few articles"))))),(0,r.kt)("li",{parentName:"ul"},"true",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'instead of return a 404 page, next.js will serve a "fallback" version of the page on the first request to such path.',(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"instead in the background, Next.js will statically generate the request path HTML and JSON. This includes running ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticProps"),"."),(0,r.kt)("li",{parentName:"ul"},"subsequent request to the same path will be served from the generated pages, just like other pages pre-rendered at build time."))),(0,r.kt)("li",{parentName:"ul"},"When should you use this?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if the app has a very large number of static pages that depend on data"),(0,r.kt)("li",{parentName:"ul"},"if you want to statically generate a small subset of pages that are popular and use ",(0,r.kt)("inlineCode",{parentName:"li"},"fallback:true")," for the rest,",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"think: e-commerce product listing"))))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blocking"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"similar to ",(0,r.kt)("inlineCode",{parentName:"li"},"fallback: true"),', except, nextjs will not serve a "fallback" version of the page on the first request to such path.',(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"instead next.js will render that page on the server and return the generated HTML."),(0,r.kt)("li",{parentName:"ul"},"the browser waits for nextjs to respond and once the HTML and JSON are received it will load the page, with no flash or loading state."))),(0,r.kt)("li",{parentName:"ul"},"When to use this?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"basically the same reason as ",(0,r.kt)("inlineCode",{parentName:"li"},"fallback: true"),", except when using ",(0,r.kt)("inlineCode",{parentName:"li"},"blocking")," you wont see a loading screen"),(0,r.kt)("li",{parentName:"ul"},"to support crawler, so instead of showing a loading page while pre-rendering, we would wait and show the actual page"))),(0,r.kt)("li",{parentName:"ul"},"Recommendation",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Nextjs recommends using ",(0,r.kt)("inlineCode",{parentName:"li"},"fallback: true")),(0,r.kt)("li",{parentName:"ul"},"use ",(0,r.kt)("inlineCode",{parentName:"li"},"fallback: true")," is you care more for user's UX, and don't have an SEO issue"),(0,r.kt)("li",{parentName:"ul"},"use ",(0,r.kt)("inlineCode",{parentName:"li"},"fallback: 'blocking'"),", is you are having an SEO issue")))))))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"//fallback true\nimport {useRouter} from \"next/router\";\n\nfunction UserDetail({user}) {\n    const router = useRouter();\n    \n    if(router.isFallback){\n        return \"Loading...\"; //will be visible when next.js is busy pre-rendering for not-found ids\n    }\n    \n    return <h1>{user.firstName} - {user.lastName} - {user.age}</h1>\n}\n\nexport default UserDetail;\n\n// generate pre-render for certain ids\nexport async function getStaticPaths() {\n\n    return {\n        paths: [\n            {params: {userid: '1'}},\n            {params: {userid: '2'}},\n            {params: {userid: '3'}},\n        ],\n        fallback: true, \n    }\n}\n  \nexport async function getStaticProps(context) {  \n    const {params} = context;\n    const response = await fetch(`https://dummyjson.com/users/${params.userid}`);  \n    const data = await response.json();  \n  \n    return {  \n        props: {\n            user: data,  \n        },  \n    };  \n}\n")),(0,r.kt)("h3",{id:"what-if-key-is-not-found"},"What if Key is Not Found"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To handle 404 pages, return not found from ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticProps"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"nextjs by default will return 404 for you")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export async function getStaticProps(context) {  \n    const {params} = context;\n    const response = await fetch(`https://dummyjson.com/users/${params.userid}`);  \n    const data = await response.json();  \n\n    //is the result is null or undefined\n    if(!data.id){\n        return {\n            notFound: True,\n        }\n    }\n\n    return {  \n        props: {\n            user: data,  \n        },  \n    };  \n}\n")),(0,r.kt)("h3",{id:"pros-and-cons-of-ssg"},"Pros and Cons of SSG"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pros",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"pre-rendered pages can be pushed to CDN, cached and served to users globally instantly."),(0,r.kt)("li",{parentName:"ul"},"better performance with SEO, as they are fast and HTML pages"))),(0,r.kt)("li",{parentName:"ul"},"cons",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the build time is dependent on the number of pages you have, for large pages it will take significant time,",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"ex:, you have a million users, and are using SSG for profile page"))),(0,r.kt)("li",{parentName:"ul"},"data might expire, if you didn't build the app recently {stale data}")))),(0,r.kt)("h3",{id:"isr-incremental-static-site-regeneration"},"ISR {incremental Static Site regeneration}"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A solution to SSG cons."),(0,r.kt)("li",{parentName:"ul"},"With ISR, Next.js allows you to update static pages after you've build your application"),(0,r.kt)("li",{parentName:"ul"},"you can statically generate individual pages without needing to rebuild the entire site, effectively solving the issue of dealing with stale data"),(0,r.kt)("li",{parentName:"ul"},"How to?",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"in the ",(0,r.kt)("inlineCode",{parentName:"li"},"getStaticProps")," function, apart from the props key, we can specify a ",(0,r.kt)("inlineCode",{parentName:"li"},"revalidate")," key"),(0,r.kt)("li",{parentName:"ul"},"the value for re-validate is the number of seconds after which a page re-generation can occur")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export async function getStaticProps(context) {  \n    const {params} = context;\n    const response = await fetch(`https://dummyjson.com/users/${params.userid}`);  \n    const data = await response.json();  \n\n    //is the result is null or undefined\n    if(!data.id){\n        return {\n            notFound: True,\n        }\n    }\n\n    return {  \n        props: {\n            user: data,  \n        },\n        revalidate: 10, //10 seconds\n    };  \n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"re-generation doesn't happen exactly after n seconds, but",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a re-generation is initiated only if a user makes a request after the re-validation time."),(0,r.kt)("li",{parentName:"ul"},"thus pages that are not frequently access won't be re-generated."))),(0,r.kt)("li",{parentName:"ul"},"the re-generation can also fail and the previous cached HTML could be served till the subsequent re-generation succeed")),(0,r.kt)("h4",{id:"programmatic-revalidation"},"Programmatic Revalidation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can programmatically invoke regeneration with next.js, for instance; if you have a webhook you can connect it to nextjs api that will invoke a regeneration"),(0,r.kt)("li",{parentName:"ul"},"this pattern is called ",(0,r.kt)("inlineCode",{parentName:"li"},"on-demand-ISR"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"export default function handler(req,res) {  \n  //check if proper app initiated this\n    if(req.query.secret !== process.env.REVALIDATION_PASSWORD ){\n        return res.status(401).json({msg: 'Invalid token'})\n    }\n\n    try{\n        await res.unstable_revalidate(\"/blog\"); //we're regernating about page\n        return res.json({revalidated: true})\n    }catch(err){\n        return res.status(500).send('Error revalidating')\n    }\n}\n")))}c.isMDXComponent=!0}}]);